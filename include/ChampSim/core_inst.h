/***
 * THIS FILE IS AUTOMATICALLY GENERATED
 * Do not edit this file. It will be overwritten when the configure script is run.
***/

#include <forward_list>

#include "ChampSim/cache.h"
#include "ChampSim/dram_controller.h"
#include "ChampSim/environment.h"
#include "ChampSim/ooo_cpu.h"
#include "ChampSim/ptw.h"
#include "ChampSim/vmem.h"
#include "ProjectConfiguration.h" // User file

#if (USER_CODES == ENABLE)

#include <cstdint>

// Replacement policy
#include "ChampSim/replacement/drrip/drrip.h"
#include "ChampSim/replacement/lru/lru.h"
#include "ChampSim/replacement/random/random.h"
#include "ChampSim/replacement/ship/ship.h"
#include "ChampSim/replacement/srrip/srrip.h"

// Prefetcher
#include "ChampSim/prefetcher/ip_stride/ip_stride.h"
#include "ChampSim/prefetcher/next_line/next_line.h"
#include "ChampSim/prefetcher/no/no.h"
#include "ChampSim/prefetcher/spp_dev/spp_dev.h"
#include "ChampSim/prefetcher/va_ampm_lite/va_ampm_lite.h"

// Branch predictor
#include "ChampSim/branch/bimodal/bimodal.h"
#include "ChampSim/branch/gshare/gshare.h"
#include "ChampSim/branch/hashed_perceptron/hashed_perceptron.h"
#include "ChampSim/branch/perceptron/perceptron.h"

// Branch target buffer
#include "ChampSim/btb/basic_btb/basic_btb.h"

#if (RAMULATOR == ENABLE)

#if (MEMORY_USE_HYBRID == ENABLE)

/** @todo Mark */

#else

/** @todo Mark */

template<unsigned long long ID, typename MEMORY_TYPE>
struct champsim::configured::generated_environment final : public champsim::environment
{
private:
    /* Hardwares' channels */
    std::vector<champsim::channel> channels;
    /** @todo make it a forward_list structure */
    /* Memory controller and its memories */
    MEMORY_CONTROLLER<MEMORY_TYPE> memory_controller;
    /* Virtual memory */
    VirtualMemory vmem;
    /* Page table walker */
    std::forward_list<PageTableWalker> ptws;
    /* Caches */
    std::forward_list<CACHE> caches;
    /* CPUs */
    std::forward_list<O3_CPU> cores;

public:
    constexpr static std::size_t num_cpus   = NUM_CPUS;
    constexpr static std::size_t block_size = BLOCK_SIZE;
    constexpr static std::size_t page_size  = PAGE_SIZE;

    generated_environment(ramulator::Memory<MEMORY_TYPE, ramulator::Controller>& memory);

    std::vector<std::reference_wrapper<O3_CPU> > cpu_view() final;
    std::vector<std::reference_wrapper<CACHE> > cache_view() final;
    std::vector<std::reference_wrapper<PageTableWalker> > ptw_view() final;
    std::vector<std::reference_wrapper<operable> > operable_view() final;
};

template<unsigned long long ID, typename MEMORY_TYPE>
champsim::configured::generated_environment<ID, MEMORY_TYPE>::generated_environment(ramulator::Memory<MEMORY_TYPE, ramulator::Controller>& memory)
: /* Hardwares' channels' initialization */
  channels {
      champsim::channel {                                     32,                                      32,                                      32,         champsim::data::bits {champsim::lg2(64)}, 1},
      champsim::channel {std::numeric_limits<std::size_t>::max(), std::numeric_limits<std::size_t>::max(), std::numeric_limits<std::size_t>::max(), champsim::data::bits {champsim::lg2(BLOCK_SIZE)}, 0},
      champsim::channel {                                     16,                                      16,                                      16,       champsim::data::bits {champsim::lg2(4096)}, 0},
      champsim::channel {                                     16,                                      16,                                      16,       champsim::data::bits {champsim::lg2(4096)}, 0},
      champsim::channel {                                     16,                                      16,                                      16,         champsim::data::bits {champsim::lg2(64)}, 0},
      champsim::channel {                                     16,                                      16,                                      16,         champsim::data::bits {champsim::lg2(64)}, 0},
      champsim::channel {                                     32,                                      32,                                      32,         champsim::data::bits {champsim::lg2(64)}, 0},
      champsim::channel {                                     32,                                       0,                                       0,  champsim::data::bits {champsim::lg2(PAGE_SIZE)}, 0},
      champsim::channel {                                     16,                                      16,                                      16,       champsim::data::bits {champsim::lg2(4096)}, 1},
      champsim::channel {                                     16,                                      16,                                      16,       champsim::data::bits {champsim::lg2(4096)}, 1},
      champsim::channel {                                     16,                                      16,                                      16,       champsim::data::bits {champsim::lg2(4096)}, 0},
      champsim::channel {                                     32,                                      32,                                      32,         champsim::data::bits {champsim::lg2(64)}, 1},
      champsim::channel {                                     32,                                      32,                                      32,         champsim::data::bits {champsim::lg2(64)}, 1},

#if (CPU_USE_MULTIPLE_CORES == ENABLE)
      champsim::channel {                                     32,                                      32,                                      32,         champsim::data::bits {champsim::lg2(64)}, 1},
      champsim::channel {std::numeric_limits<std::size_t>::max(), std::numeric_limits<std::size_t>::max(), std::numeric_limits<std::size_t>::max(), champsim::data::bits {champsim::lg2(BLOCK_SIZE)}, 0},
      champsim::channel {                                     16,                                      16,                                      16,       champsim::data::bits {champsim::lg2(4096)}, 0},
      champsim::channel {                                     16,                                      16,                                      16,       champsim::data::bits {champsim::lg2(4096)}, 0},
      champsim::channel {                                     16,                                      16,                                      16,         champsim::data::bits {champsim::lg2(64)}, 0},
      champsim::channel {                                     16,                                      16,                                      16,         champsim::data::bits {champsim::lg2(64)}, 0},
      champsim::channel {                                     32,                                      32,                                      32,         champsim::data::bits {champsim::lg2(64)}, 0},
      champsim::channel {                                     32,                                       0,                                       0,  champsim::data::bits {champsim::lg2(PAGE_SIZE)}, 0},
      champsim::channel {                                     16,                                      16,                                      16,       champsim::data::bits {champsim::lg2(4096)}, 1},
      champsim::channel {                                     16,                                      16,                                      16,       champsim::data::bits {champsim::lg2(4096)}, 1},
      champsim::channel {                                     16,                                      16,                                      16,       champsim::data::bits {champsim::lg2(4096)}, 0},
      champsim::channel {                                     32,                                      32,                                      32,         champsim::data::bits {champsim::lg2(64)}, 1},
      champsim::channel {                                     32,                                      32,                                      32,         champsim::data::bits {champsim::lg2(64)}, 1},
#endif /* CPU_USE_MULTIPLE_CORES */
},
  /* Memory controller's initialization */
  memory_controller(MEMORY_CONTROLLER_CLOCK_SCALE, CPU_FREQUENCY / memory.spec->speed_entry.freq, {&LLC_to_MEMORY_CONTROLLER_queues}, memory)
  // DRAM {champsim::chrono::picoseconds {312}, champsim::chrono::picoseconds {625}, std::size_t {24}, std::size_t {24}, std::size_t {24}, std::size_t {52}, champsim::chrono::microseconds {32000}, {&channels.at(1)}, 64, 64, 1, champsim::data::bytes {8}, 65536, 1024, 1, 8, 4, 8192},

  /* Virtual memory's initialization */
  vmem(PAGE_SIZE, PAGE_TABLE_LEVELS, MINOR_FAULT_PENALTY, memory.max_address)
  // vmem {champsim::data::bytes {4096}, 5, champsim::chrono::picoseconds {250 * 200}, DRAM, 1},

  /* Page table walker's initialization */
  ptws {build<PageTableWalker>(champsim::ptw_builder {champsim::defaults::default_ptw}.name("cpu0_PTW").upper_levels({&channels.at(7)}).virtual_memory(&vmem).name("cpu0_PTW").cpu(0).lower_level(&channels.at(0)).clock_period(champsim::chrono::picoseconds {250}))},
  /* Caches' initialization */
  caches {build<CACHE>(
      /* CPU 0's caches */
      // Last level cache (LLC)
      champsim::cache_builder {champsim::defaults::default_llc}.name("LLC").upper_levels({&channels.at(6)}).offset_bits(champsim::data::bits {champsim::lg2(64)}).replacement<class lru>().prefetcher<class no>().lower_level(&channels.at(1)).clock_period(champsim::chrono::picoseconds {250}),
      // Data translation lookaside buffer (DTLB)
      champsim::cache_builder {champsim::defaults::default_dtlb}.name("cpu0_DTLB").upper_levels({&channels.at(8)}).offset_bits(champsim::data::bits {champsim::lg2(4096)}).replacement<class lru>().prefetcher<class no>().lower_level(&channels.at(2)).clock_period(champsim::chrono::picoseconds {250}),
      // Instruction translation lookaside buffer (ITLB)
      champsim::cache_builder {champsim::defaults::default_itlb}.name("cpu0_ITLB").upper_levels({&channels.at(9)}).offset_bits(champsim::data::bits {champsim::lg2(4096)}).replacement<class lru>().prefetcher<class no>().lower_level(&channels.at(3)).clock_period(champsim::chrono::picoseconds {250}),
      // Level 1 data cache
      champsim::cache_builder {champsim::defaults::default_l1d}.name("cpu0_L1D").upper_levels({{&channels.at(0), &channels.at(12)}}).offset_bits(champsim::data::bits {champsim::lg2(64)}).replacement<class lru>().prefetcher<class no>().lower_translate(&channels.at(8)).lower_level(&channels.at(4)).clock_period(champsim::chrono::picoseconds {250}),
      // Level 1 instruction cache
      champsim::cache_builder {champsim::defaults::default_l1i}.name("cpu0_L1I").upper_levels({&channels.at(11)}).offset_bits(champsim::data::bits {champsim::lg2(64)}).replacement<class lru>().prefetcher<class no>().lower_translate(&channels.at(9)).lower_level(&channels.at(5)).clock_period(champsim::chrono::picoseconds {250}),
      // Level 2 cache
      champsim::cache_builder {champsim::defaults::default_l2c}.name("cpu0_L2C").upper_levels({{&channels.at(4), &channels.at(5)}}).offset_bits(champsim::data::bits {champsim::lg2(64)}).replacement<class lru>().prefetcher<class no>().lower_translate(&channels.at(10)).lower_level(&channels.at(6)).clock_period(champsim::chrono::picoseconds {250}),
      // Second Level TLB
      champsim::cache_builder {champsim::defaults::default_stlb}.name("cpu0_STLB").upper_levels({{&channels.at(2), &channels.at(3), &channels.at(10)}}).offset_bits(champsim::data::bits {champsim::lg2(4096)}).replacement<class lru>().prefetcher<class no>().lower_level(&channels.at(7)).clock_period(champsim::chrono::picoseconds {250}))},
  /* CPUs' initialization */
  cores {build<O3_CPU>(
      /* CPU 0 */
      champsim::core_builder {champsim::defaults::default_core}.l1i(&(*std::next(std::begin(caches), 4))).l1i_bandwidth((*std::next(std::begin(caches), 4)).MAX_TAG).fetch_queues(&channels.at(11)).l1d_bandwidth((*std::next(std::begin(caches), 3)).MAX_TAG).data_queues(&channels.at(12)).branch_predictor<class hashed_perceptron>().btb<class basic_btb>().index(0).clock_period(champsim::chrono::picoseconds {250}))}
{
}

template<unsigned long long ID, typename MEMORY_TYPE>
auto champsim::configured::generated_environment<ID, MEMORY_TYPE>::cpu_view() -> std::vector<std::reference_wrapper<O3_CPU> >
{
    std::vector<std::reference_wrapper<O3_CPU> > retval {};
    auto make_ref = [](auto& x)
    { return std::ref(x); };

    std::transform(std::begin(cores), std::end(cores), std::back_inserter(retval), make_ref);

    return retval;
}

template<unsigned long long ID, typename MEMORY_TYPE>
auto champsim::configured::generated_environment<ID, MEMORY_TYPE>::cache_view() -> std::vector<std::reference_wrapper<CACHE> >
{
    std::vector<std::reference_wrapper<CACHE> > retval {};
    auto make_ref = [](auto& x)
    { return std::ref(x); };

    std::transform(std::begin(caches), std::end(caches), std::back_inserter(retval), make_ref);

    return retval;
}

template<unsigned long long ID, typename MEMORY_TYPE>
auto champsim::configured::generated_environment<ID, MEMORY_TYPE>::ptw_view() -> std::vector<std::reference_wrapper<PageTableWalker> >
{
    std::vector<std::reference_wrapper<PageTableWalker> > retval {};
    auto make_ref = [](auto& x)
    { return std::ref(x); };

    std::transform(std::begin(ptws), std::end(ptws), std::back_inserter(retval), make_ref);

    return retval;
}

template<unsigned long long ID, typename MEMORY_TYPE>
auto champsim::configured::generated_environment<ID, MEMORY_TYPE>::operable_view() -> std::vector<std::reference_wrapper<champsim::operable> >
{
    std::vector<std::reference_wrapper<champsim::operable> > retval {};
    auto make_ref = [](auto& x)
    { return std::ref<champsim::operable>(x); };

    std::transform(std::begin(cores), std::end(cores), std::back_inserter(retval), make_ref);
    std::transform(std::begin(caches), std::end(caches), std::back_inserter(retval), make_ref);
    std::transform(std::begin(ptws), std::end(ptws), std::back_inserter(retval), make_ref);
    retval.push_back(std::ref<champsim::operable>(memory_controller));

    return retval;
}

#endif /* MEMORY_USE_HYBRID */

#else

template<>
struct champsim::configured::generated_environment<CHAMPSIM_BUILD> final : public champsim::environment
{
private:
    using index_type = uint32_t;

    /* Hardwares' channels' index */
    enum class ChannelIndex : index_type
    {
        /* CPU 0's channels */
        CPU0_PTW_to_CPU0_L1D_Queues = 0, // CPU 0 PTW to CPU 0 L1D queues
        CPU0_DTLB_to_CPU0_STLB_Queues,   // CPU 0 DTLB to CPU 0 STLB queues
        CPU0_ITLB_to_CPU0_STLB_Queues,   // CPU 0 ITLB to CPU 0 STLB queues
        CPU0_L1D_to_CPU0_L2C_Queues,     // CPU 0 L1D to CPU 0 L2C queues
        CPU0_L1I_to_CPU0_L2C_Queues,     // CPU 0 L1I to CPU 0 L2C queues
        CPU0_L2C_to_LLC_Queues,          // CPU 0 L2C to LLC queues
        CPU0_STLB_to_CPU0_PTW_Queues,    // CPU 0 STLB to CPU 0 PTW queues
        CPU0_L1D_to_CPU0_DTLB_Queues,    // CPU 0 L1D to CPU 0 DTLB queues
        CPU0_L1I_to_CPU0_ITLB_Queues,    // CPU 0 L1I to CPU 0 ITLB queues
        CPU0_L2C_to_CPU0_STLB_Queues,    // CPU 0 L2C to CPU 0 STLB queues
        CPU0_to_CPU0_L1I_Queues,         // CPU 0 to CPU 0 L1I queues
        CPU0_to_CPU0_L1D_Queues,         // CPU 0 to CPU 0 L1D queues

#if (CPU_USE_MULTIPLE_CORES == ENABLE)
        /* CPU 1's channels */
        CPU1_PTW_to_CPU1_L1D_Queues,   // CPU 1 PTW to CPU 1 L1D queues
        CPU1_DTLB_to_CPU1_STLB_Queues, // CPU 1 DTLB to CPU 1 STLB queues
        CPU1_ITLB_to_CPU1_STLB_Queues, // CPU 1 ITLB to CPU 1 STLB queues
        CPU1_L1D_to_CPU1_L2C_Queues,   // CPU 1 L1D to CPU 1 L2C queues
        CPU1_L1I_to_CPU1_L2C_Queues,   // CPU 1 L1I to CPU 1 L2C queues
        CPU1_L2C_to_LLC_Queues,        // CPU 1 L2C to LLC queues
        CPU1_STLB_to_CPU1_PTW_Queues,  // CPU 1 STLB to CPU 1 PTW queues
        CPU1_L1D_to_CPU1_DTLB_Queues,  // CPU 1 L1D to CPU 1 DTLB queues
        CPU1_L1I_to_CPU1_ITLB_Queues,  // CPU 1 L1I to CPU 1 ITLB queues
        CPU1_L2C_to_CPU1_STLB_Queues,  // CPU 1 L2C to CPU 1 STLB queues
        CPU1_to_CPU1_L1I_Queues,       // CPU 1 to CPU 1 L1I queues
        CPU1_to_CPU1_L1D_Queues,       // CPU 1 to CPU 1 L1D queues

#endif /* CPU_USE_MULTIPLE_CORES */

        /* LLC to DRAM queues */
        LLC_to_DRAM_Queues,
        Max
    };
    /* Hardwares' channels */
    std::vector<champsim::channel> channels;
    /* Memory */
    MEMORY_CONTROLLER DRAM;
    /* Virtual memory */
    VirtualMemory vmem;
    /* Page table walker */
    std::forward_list<PageTableWalker> ptws;
    /* Caches */
    std::forward_list<CACHE> caches;
    /* CPUs */
    std::forward_list<O3_CPU> cores;

public:
    constexpr static std::size_t num_cpus   = NUM_CPUS;
    constexpr static std::size_t block_size = BLOCK_SIZE;
    constexpr static std::size_t page_size  = PAGE_SIZE;

    generated_environment();
    std::vector<std::reference_wrapper<O3_CPU> > cpu_view() final;
    std::vector<std::reference_wrapper<CACHE> > cache_view() final;
    std::vector<std::reference_wrapper<PageTableWalker> > ptw_view() final;
    MEMORY_CONTROLLER& dram_view() final;
    std::vector<std::reference_wrapper<operable> > operable_view() final;
};

#endif /* RAMULATOR */

#else
/* Original code of ChampSim */

template<>
struct champsim::configured::generated_environment<0x11a7870cb042c20b> final : public champsim::environment
{
private:
    std::vector<champsim::channel> channels;
    MEMORY_CONTROLLER DRAM;
    VirtualMemory vmem;
    std::forward_list<PageTableWalker> ptws;
    std::forward_list<CACHE> caches;
    std::forward_list<O3_CPU> cores;

public:
    constexpr static std::size_t num_cpus   = 1;
    constexpr static std::size_t block_size = 64;
    constexpr static std::size_t page_size  = 4096;
    generated_environment();
    std::vector<std::reference_wrapper<O3_CPU> > cpu_view() final;
    std::vector<std::reference_wrapper<CACHE> > cache_view() final;
    std::vector<std::reference_wrapper<PageTableWalker> > ptw_view() final;
    MEMORY_CONTROLLER& dram_view() final;
    std::vector<std::reference_wrapper<operable> > operable_view() final;
};

#endif /* USER_CODES */
